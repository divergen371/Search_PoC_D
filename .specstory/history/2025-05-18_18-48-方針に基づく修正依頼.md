<!-- Generated by SpecStory -->

# 方針に基づく修正依頼 (2025-05-19 03:48:59)

_**User**_

その方針で修正して

---

_**Assistant**_



---

Read file: source/language_table.d

---

Read file: source/language_table.d

---

<details>
            <summary>Searched codebase "BK-Tree serializeForCache deserializeFromCache 問題" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L2950-3008 |
| `source/language_table.d` | L3405-3458 |
| `source/language_table.d` | L3057-3113 |
| `source/language_table.d` | L3706-3763 |
| `source/language_table.d` | L2882-2950 |
| `source/language_table.d` | L3667-3706 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L3458-3490 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L435-479 |
| `source/language_table.d` | L3556-3623 |
| `source/language_table.d` | L3490-3556 |
| `source/language_table.d` | L2686-2747 |
| `source/language_table.d` | L3623-3667 |
| `source/language_table.d` | L3287-3330 |
| `source/language_table.d` | L3385-3405 |
| `source/language_table.d` | L2774-2837 |
| `source/language_table.d` | L3255-3287 |
| `source/language_table.d` | L2338-2394 |
| `README.md` | L107-163 |
| `source/language_table.d` | L699-747 |
| `source/language_table.d` | L2747-2774 |
| `source/language_table.d` | L2837-2882 |
| `source/language_table.d` | L3330-3385 |
| `source/language_table.d` | L653-670 |

</details>

---

```diff
          SerializedNode[] result;
          Node*[] nodeQueue;
-         Node*[Node*] visited; // 訪問済みノードの追跡
+         Node*[size_t] nodeIndices; // ノードポインタからインデックスへのマッピング
          
          // ルートをキューに追加
          nodeQueue ~= root;
          
+         // 最初のパス: すべてのノードを収集してインデックスを割り当て
          while (nodeQueue.length > 0)
          {
```

```diff
              
              // 既に処理済みならスキップ
-             if (current in visited)
+             if (current in nodeIndices)
                  continue;
                  
-             // このノードを訪問済みに
-             visited[current] = current;
+             // このノードにインデックスを割り当て
+             size_t currentIndex = result.length;
+             nodeIndices[current] = currentIndex;
              
-             // このノードの情報を保存
+             // このノードの情報を保存（リンク情報はまだ設定しない）
              SerializedNode sNode;
              sNode.word = current.word;
              sNode.id = current.id;
              
-             // 子ノードをキューに追加し、インデックスをマッピング
-             size_t currentIndex = result.length; // このノードのインデックス
+             // このノードをシリアライズ結果に追加
+             result ~= sNode;
              
+             // 子ノードをキューに追加
              foreach (dist, child; current.children)
              {
                  if (child !is null)
                  {
-                     // 子ノードをキューに追加
                      nodeQueue ~= child;
-                     
-                     // 子ノードのインデックスは後で埋める（一時的に1を設定）
-                     sNode.links[dist] = 1; 
                  }
              }
-             
-             // このノードをシリアライズ結果に追加
-             result ~= sNode;
          }
          
-         // 二回目のパスで子ノードのインデックスを修正
-         for (size_t i = 0; i < result.length; i++)
-         {
-             auto links = result[i].links.keys;
-             foreach (dist; links)
-             {
-                 // このノードの子と同じワードを持つノードをシリアライズ配列から探す
-                 string targetWord = "";
-                 Node* sourceNode = null;
-                 
-                 // BFSと同じ方法でノードを探し出す
-                 if (i == 0) 
-                     sourceNode = root;
-                 else
-                 {
-                     // 最初のパスと同じように訪問する順番でノードを特定
-                     size_t nodeIndex = 0;
-                     Node*[] tempQueue;
-                     Node*[Node*] tempVisited;
-                     
-                     tempQueue ~= root;
-                     
-                     while (tempQueue.length > 0 && nodeIndex <= i)
-                     {
-                         Node* current = tempQueue[0];
-                         tempQueue = tempQueue[1..$];
-                         
-                         if (current in tempVisited)
-                             continue;
-                             
-                         tempVisited[current] = current;
-                         
-                         if (nodeIndex == i)
-                         {
-                             sourceNode = current;
-                             break;
-                         }
-                         
-                         foreach (childDist, child; current.children)
-                         {
-                             if (child !is null)
-                                 tempQueue ~= child;
-                         }
-                         
-                         nodeIndex++;
-                     }
-                 }
-                 
-                 if (sourceNode !is null)
+         // 2番目のパス: リンク情報をセット
+         foreach (node, index; nodeIndices)
+         {
+             foreach (dist, child; node.children)
+             {
+                 if (child !is null && child in nodeIndices)
                  {
-                     auto childNode = sourceNode.children[dist];
-                     targetWord = childNode.word;
-                     
-                     // 対応するワードを持つノードのインデックスを探す
-                     for (size_t j = 0; j < result.length; j++)
-                     {
-                         if (result[j].word == targetWord && j != i)
-                         {
-                             result[i].links[dist] = cast(uint)j;
-                             break;
-                         }
-                     }
-                 }
-             }
-         }
-         
+                     // 子ノードのインデックスを参照
+                     result[index].links[dist] = cast(uint)nodeIndices[child];
+                 }
+             }
+         }
+         
+         writefln("BK-Tree シリアライズ完了: %d ノード", result.length);
          return result;
      }
```

```diff
          if (nodes.length == 0)
              return;
+         
+         this.root = null;  // 既存のツリーをクリア
+         this.nodeCount = 0;
              
          // ノードごとにツリーに追加
```

---

```bash
cd /home/diverge/D/Search_PoC_D && dmd -run source/language_table.d
```

---

_**User**_



---

_**Assistant**_



---

リンターエラーを修正する必要があります。Node*型とsize_t型の関連付けが逆になっています。修正します。

---



---

_**User**_

せっかくキャッシュを作成したのになぜBK-Treeを再構築しているのですか？

---

_**Assistant**_



---

BK-Treeがキャッシュから正しく復元されているにも関わらず再構築されている問題があるようですね。ログを確認すると、次のような流れになっています：

1. まずキャッシュからBK-Treeを含むすべてのインデックスを正常に読み込んでいます：
```
キャッシュからBK-Treeを読み込んでいます（ノード数: 189927）...
BK-Tree復元完了：189927 ノード
```

2. その後、既存のCSVファイルも読み込んでいます：
```
既存のCSVファイルを読み込んでいます...
```

3. そして再度BK-Treeが構築されています：
```
BK-Tree構築を開始...
BK-Tree構築: 100% (189927/189927)
```

これは、キャッシュから読み込みに成功した後でも、CSVファイル処理のロジックが実行されているためです。プログラムがキャッシュのロード成功を認識しても、既存CSVファイルの処理をスキップしていないことが問題です。

コードを修正して、キャッシュのロードが成功した場合はCSVからの再構築をスキップするように変更する必要があります。

---

_**User**_

そのように修正してください

---

_**Assistant**_



---

<details>
            <summary>Searched codebase "キャッシュが有効なら読み込み cacheLoaded CSVファイルが存在する" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L653-670 |
| `source/language_table.d` | L699-747 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L435-479 |
| `source/language_table.d` | L3137-3202 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L670-699 |
| `source/language_table.d` | L568-603 |
| `source/language_table.d` | L747-791 |
| `source/language_table.d` | L3614-3653 |
| `source/language_table.d` | L891-940 |
| `source/language_table.d` | L603-653 |
| `README.md` | L107-163 |
| `source/language_table.d` | L3653-3710 |
| `source/language_table.d` | L847-891 |
| `source/language_table.d` | L3332-3352 |
| `source/language_table.d` | L2021-2067 |
| `source/language_table.d` | L2111-2157 |
| `source/language_table.d` | L2067-2111 |
| `source/language_table.d` | L3437-3503 |
| `source/language_table.d` | L940-976 |
| `source/language_table.d` | L3405-3437 |
| `source/language_table.d` | L2950-3006 |
| `source/language_table.d` | L3352-3405 |
| `source/language_table.d` | L3503-3570 |

</details>

---



---



---

Read file: source/language_table.d

---



---

```diff
                  writeln("キャッシュの状態: cacheLoaded=", cacheLoaded, ", needsUpdate=", cache.shouldUpdate());
                  // 条件判定をスキップして常に保存する
+                 if (!cacheLoaded) // キャッシュがロードされていない場合のみ保存
                  {
                      writeln("キャッシュを強制保存します...");
                      cache.saveComplete(prefixTree, suffixTree, gramIndex, lengthIndex, bkTree);
                      cache.resetUpdateFlag();
                  }
+                 else
+                 {
+                     writeln("キャッシュからロード済みのため、保存をスキップします");
+                 }
              }
              else
```

```diff
                  writeln("キャッシュの状態: cacheLoaded=", cacheLoaded, ", needsUpdate=", cache.shouldUpdate());
                  // 条件判定をスキップして常に保存する
+                 if (!cacheLoaded) // キャッシュがロードされていない場合のみ保存
                  {
                      writeln("キャッシュを強制保存します...");
                      cache.saveComplete(prefixTree, suffixTree, gramIndex, lengthIndex, bkTree);
                      cache.resetUpdateFlag();
                  }
+                 else
+                 {
+                     writeln("キャッシュからロード済みのため、保存をスキップします");
+                 }
              }
  
```

---

```bash
cd /home/diverge/D/Search_PoC_D && dmd -run source/language_table.d
```

---

_**User**_

ビルドには成功しましたが相変わらずキャッシュを読み込んだのにBK-Treeを構築しています。

---

_**Assistant**_



---

まだ問題が残っているようですね。キャッシュを読み込んでいるのにBK-Treeが再構築されています。

ログを確認すると、CSVファイルの読み込みがスキップされていないのが分かります。また、より深刻な問題として、`buildIndicesFromEntries`関数内部でBK-Treeが再構築されているようです。

この関数内でもキャッシュ読み込み済みのデータを再構築しないように修正する必要があります。次の変更を行いましょう：

---

<details>
            <summary>Searched codebase "buildIndicesFromEntries BK-Tree 構築" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L2323-2348 |
| `source/language_table.d` | L2348-2404 |
| `source/language_table.d` | L2535-2582 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L3016-3070 |
| `source/language_table.d` | L2960-3016 |
| `source/language_table.d` | L3362-3415 |
| `source/language_table.d` | L2582-2636 |
| `source/language_table.d` | L3513-3580 |
| `source/language_table.d` | L901-950 |
| `source/language_table.d` | L2696-2757 |
| `source/language_table.d` | L2892-2960 |
| `source/language_table.d` | L3663-3720 |
| `source/language_table.d` | L3580-3624 |
| `source/language_table.d` | L3447-3513 |
| `source/language_table.d` | L704-752 |
| `source/language_table.d` | L3415-3447 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L2784-2847 |
| `source/language_table.d` | L3244-3287 |
| `source/language_table.d` | L435-479 |
| `source/language_table.d` | L2847-2892 |
| `source/language_table.d` | L2404-2462 |
| `source/language_table.d` | L3287-3342 |
| `source/language_table.d` | L2757-2784 |

</details>

---

Read file: source/language_table.d

---

```diff
   *      lengthIndex = 長さ検索用のインデックス（出力）
   *      bkTree = 類似検索用のBK-Tree（出力）
+  *      skipBKTree = BK-Treeの構築をスキップするフラグ（キャッシュ読み込み済みの場合true）
   */
  void buildIndicesFromEntries(
```

```diff
      ref GramIndexType[string] gramIndex,
      ref bool[size_t][size_t] lengthIndex,
-     ref BKTree bkTree)
+     ref BKTree bkTree,
+     bool skipBKTree = false)
  {
      StopWatch sw;
```

```diff
      idDict.clear();
      lengthIndex.clear();
-     // BK-Treeは新しく作成
+     
+     // BK-Treeは必要な場合のみ新しく作成
+     if (!skipBKTree) {
          bkTree = new BKTree(&damerauDistanceLimited, 3);
+     } else {
+         writeln("BK-Tree はキャッシュから読み込み済みのため、再構築をスキップします");
+     }
  
      // rehashメソッドの代わりに、十分な容量を確保してから登録する
```

```diff
  
      // BK-Treeを安全に構築（並列処理の外で実行）
+     if (!skipBKTree) {
          writeln("BK-Tree構築を開始...");
  
```

```diff
  
          writeln("\nBK-Tree構築完了");
+     }
+     
      GC.collect();
  
```

```diff
  
      // BK-Tree統計
+     if (!skipBKTree) {
          bkTree.printStats();
+     } else {
+         writeln("BK-Tree統計はスキップ（キャッシュ読み込み済み）");
+     }
  
      // インデックス構築後のメモリ使用状況を報告
```

---

<details>
            <summary>Searched codebase "buildIndicesFromEntries 呼び出し cacheLoaded" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L704-752 |
| `source/language_table.d` | L653-675 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L435-479 |
| `source/language_table.d` | L3147-3212 |
| `source/language_table.d` | L901-950 |
| `source/language_table.d` | L2323-2348 |
| `source/language_table.d` | L3362-3415 |
| `source/language_table.d` | L2960-3016 |
| `source/language_table.d` | L3016-3070 |
| `source/language_table.d` | L2348-2404 |
| `source/language_table.d` | L2535-2582 |
| `source/language_table.d` | L3663-3720 |
| `source/language_table.d` | L3244-3287 |
| `source/language_table.d` | L3447-3513 |
| `source/language_table.d` | L2582-2636 |
| `source/language_table.d` | L3513-3580 |
| `source/language_table.d` | L3415-3447 |
| `source/language_table.d` | L752-798 |
| `source/language_table.d` | L2489-2535 |
| `source/language_table.d` | L2462-2489 |
| `source/language_table.d` | L3580-3624 |
| `source/language_table.d` | L675-704 |
| `source/language_table.d` | L603-653 |

</details>

---



---

Read file: source/language_table.d

---



---

```diff
                  // 辞書とインデックス構築を最適化
                  buildIndicesFromEntries(
-                     entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree
+                     entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree, cacheLoaded
                  );
  
```

```diff
                  // 辞書とインデックス構築を最適化
                  buildIndicesFromEntries(
-                     entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree
+                     entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree, cacheLoaded
                  );
  
```

```diff
                      // インデックス再構築
                      buildIndicesFromEntries(
-                         entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree
+                         entries, wordDict, idDict, prefixTree, suffixTree, gramIndex, lengthIndex, bkTree, cacheLoaded
                      );
  
```

---

```bash
cd /home/diverge/D/Search_PoC_D && dmd -run source/language_table.d
```

---

_**User**_

ビルドには成功しキャッシュの活用も出来ていますが新たな問題が発生しました

---

_**Assistant**_



---

セグメンテーションフォルトが発生していますね。キャッシュからの読み込みは成功しているものの、検索操作時にメモリアクセス違反が起きています。

問題の原因は、デシリアライズされたBK-Treeと辞書データ構造の間に不整合があると考えられます。この現象はよくあるキャッシュの破損や不完全なシリアライズが原因です。

問題解決のための対策を提案します：

1. **キャッシュの再生成**
   キャッシュファイルを削除して新規に作成するのが簡単な解決策です：
   ```
   rm /home/diverge/D/Search_PoC_D/language_data.csv.cache
   ```

2. **デシリアライズ処理の修正**
   deserializeFromCache関数を改善し、単純にノードを追加するだけでなく、関係性も正しく復元するように修正が必要です。

3. **検索操作の安全性強化**
   search関数に例外処理とnullチェックを追加して、不正なメモリアクセスを回避する改修を行うことが重要です。

どの方法から試すか指示をいただければ、具体的な実装を提案します。

---

_**User**_

デシリアライズ処理の修正
deserializeFromCache関数を改善し、単純にノードを追加するだけでなく、関係性も正しく復元するように修正を行う
検索操作の安全性強化
search関数に例外処理とnullチェックを追加して、不正なメモリアクセスを回避する
BK-Treeとそれ以外のインデックスでファイルを分ける

---

_**Assistant**_



---

それでは、指示された3つの対策を実装していきます。

---

<details>
            <summary>Searched codebase "deserializeFromCache 関数 BKTree" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L2974-3030 |
| `source/language_table.d` | L3030-3084 |
| `source/language_table.d` | L3677-3734 |
| `source/language_table.d` | L3376-3429 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L3638-3677 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L2906-2974 |
| `source/language_table.d` | L3429-3461 |
| `source/language_table.d` | L3461-3527 |
| `source/language_table.d` | L3527-3594 |
| `source/language_table.d` | L435-479 |
| `source/language_table.d` | L3594-3638 |
| `source/language_table.d` | L2350-2408 |
| `source/language_table.d` | L3258-3301 |
| `source/language_table.d` | L704-752 |
| `source/language_table.d` | L3356-3376 |
| `README.md` | L107-163 |
| `source/language_table.d` | L2323-2350 |
| `source/language_table.d` | L3161-3226 |
| `source/language_table.d` | L2734-2771 |
| `source/language_table.d` | L2798-2861 |
| `source/language_table.d` | L653-675 |
| `source/language_table.d` | L901-950 |
| `source/language_table.d` | L2581-2642 |

</details>

---

<details>
            <summary>Searched codebase "search 関数 BKTree Result[]" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `source/language_table.d` | L3030-3084 |
| `source/language_table.d` | L2906-2974 |
| `source/language_table.d` | L3112-3161 |
| `source/language_table.d` | L2224-2290 |
| `source/language_table.d` | L2974-3030 |
| `source/language_table.d` | L2734-2771 |
| `source/language_table.d` | L1726-1765 |
| `source/language_table.d` | L1980-2031 |
| `source/language_table.d` | L3084-3112 |
| `source/language_table.d` | L986-1028 |
| `source/language_table.d` | L3677-3734 |
| `source/language_table.d` | L1028-1071 |
| `source/language_table.d` | L2861-2906 |
| `source/language_table.d` | L2771-2798 |
| `source/language_table.d` | L518-568 |
| `source/language_table.d` | L1505-1547 |
| `source/language_table.d` | L3527-3594 |
| `source/language_table.d` | L3638-3677 |
| `source/language_table.d` | L2798-2861 |
| `source/language_table.d` | L2350-2408 |
| `source/language_table.d` | L479-518 |
| `source/language_table.d` | L2642-2665 |
| `source/language_table.d` | L3429-3461 |
| `source/language_table.d` | L3461-3527 |
| `source/language_table.d` | L2581-2642 |

</details>

---

Read file: source/language_table.d

---

それでは、指示された3つの修正を行います。

1. まず、deserializeFromCacheの改善を行います：

---



---

```diff
      /**
       * シリアライズされた情報からBK-Treeを再構築する
+      *
+      * シリアライズされたノード配列から、元のBK-Treeの関係性を正確に復元します。
+      * 単にノードを追加するだけでなく、ノード間の親子関係を再構築します。
       *
       * Params:
```

```diff
          this.nodeCount = 0;
          
-         // ノードごとにツリーに追加
-         foreach (i, node; nodes)
+         // ノードオブジェクトを作成して配列に格納
+         Node*[] nodeObjects;
+         nodeObjects.length = nodes.length;
+         
+         try {
+             // 最初のパス：すべてのノードオブジェクトを作成
+             foreach (i, ref node; nodes)
              {
-             // すでにIDでノードを登録
-             insert(node.word, node.id);
+                 nodeObjects[i] = new Node(node.word, node.id);
+             }
+             
+             // ルートノードを設定（通常は最初のノード）
+             if (nodeObjects.length > 0)
+                 this.root = nodeObjects[0];
+             
+             // 二番目のパス：リンク情報に基づいて関係を復元
+             foreach (i, ref node; nodes)
+             {
+                 // 各距離の子ノードの参照関係を復元
+                 foreach (dist, childIdx; node.links)
+                 {
+                     // 範囲チェック
+                     if (childIdx < nodeObjects.length)
+                     {
+                         nodeObjects[i].children[dist] = nodeObjects[childIdx];
                      }
+                     else
+                     {
+                         writefln("警告: 無効なノードインデックス %d (最大 %d)", childIdx, nodeObjects.length - 1);
+                     }
+                 }
+             }
+             
+             // ノード数を更新
+             this.nodeCount = nodes.length;
              
-         writefln("BK-Tree復元完了：%d ノード", nodeCount);
+             writefln("BK-Tree復元完了：%d ノード (関係性を含む)", this.nodeCount);
+         }
+         catch (Exception e)
+         {
+             // エラー発生時は部分的に構築されたツリーを破棄して新規作成
+             writeln("BK-Tree復元中にエラー発生: ", e.msg);
+             this.root = null;
+             this.nodeCount = 0;
+             this.root = new Node("", 0); // ダミールートの作成
+             writeln("警告: エラーのため空のBK-Treeを作成しました");
+         }
      }
  
```

---

2. 次に、search関数の安全性強化を行います：

---

```diff
       * 三角不等式を利用して探索空間を効率的に絞り込みます。
       * 
+      * メモリアクセスの安全性を確保するため、nullチェックと例外処理を強化しています。
+      *
       * Params:
       *      query = 検索する単語
```

```diff
          Result[] results;
          
+         try
+         {
+             // NULLチェック
              if (root is null)
+             {
+                 writeln("警告: BK-Treeルートがnullです");
                  return results;
+             }
+             
+             // クエリが空の場合は早期リターン
+             if (query.length == 0)
+             {
+                 writeln("警告: 検索クエリが空です");
+                 return results;
+             }
  
              // 最大距離は設定された最大以下に制限
```

```diff
              // ルートから開始
              queue.insertBack(QueueItem(root));
+ 
+             // 循環参照検出用 (安全対策)
+             bool[Node*] visitedNodes;
+             size_t maxVisitCount = 100_000; // 安全のための上限値
+             size_t visitCount = 0;
  
              while (!queue.empty)
              {
+                 // 安全対策: 訪問ノード数が上限を超えたら中断
+                 if (++visitCount > maxVisitCount)
+                 {
+                     writeln("警告: BK-Tree検索が上限に達しました。結果が不完全な可能性があります");
+                     break;
+                 }
+                 
                  // キューから取り出し
                  auto item = queue.front;
                  queue.removeFront();
+ 
+                 // nullチェック（破損したツリー対策）
+                 if (item.node is null)
+                     continue;
                      
                  auto node = item.node;
+                 
+                 // 循環参照検出（破損したツリー対策）
+                 if (node in visitedNodes)
+                     continue;
+                 visitedNodes[node] = true;
+ 
+                 // 単語の長さをチェック（不正なデータ対策）
+                 if (node.word.length > 1000)
+                 {
+                     writeln("警告: 異常に長い単語をスキップします");
+                     continue;
+                 }
  
                  // 現在ノードとクエリとの距離を計算
                  // 実際の距離を取得するために十分な上限を設定する。
                  size_t limit = (query.length >= node.word.length ? query.length : node.word.length) + 1;
-             size_t dist = distanceFn(query, node.word, limit);
+                 
+                 // 距離計算での例外をキャッチ
+                 size_t dist;
+                 try
+                 {
+                     dist = distanceFn(query, node.word, limit);
+                 }
+                 catch (Exception e)
+                 {
+                     writeln("警告: 距離計算中に例外が発生しました: ", e.msg);
+                     continue;
+                 }
  
                  // 完全一致の場合は最優先で追加
```

```diff
                  }
  
+                 // 子ノードの数が異常に多くないかチェック（破損したツリー対策）
+                 if (node.children.length > 1000)
+                 {
+                     writeln("警告: 子ノード数が異常に多いため、一部の子ノードのみ訪問します");
+                     // 距離の小さい方から先に探索するために、キーでソート
+                     auto sortedDists = node.children.keys;
+                     import std.algorithm.sorting : sort;
+                     sort(sortedDists);
+                     
+                     size_t count = 0;
+                     foreach (d; sortedDists)
+                     {
+                         if (count++ >= 1000)
+                             break;
+                             
+                         if (d >= lowerBound && d <= upperBound)
+                         {
+                             if (auto childPtr = d in node.children)
+                             {
+                                 if (*childPtr !is null)
+                                     queue.insertBack(QueueItem(*childPtr));
+                             }
+                         }
+                     }
+                 }
+                 else
+                 {
+                     // 通常の探索
                      for (size_t d = lowerBound; d <= upperBound; d++)
                      {
                          if (auto childPtr = d in node.children)
+                         {
+                             if (*childPtr !is null) // nullチェック追加
                                  queue.insertBack(QueueItem(*childPtr));
+                         }
+                     }
                  }
              }
```

```diff
              import std.algorithm.sorting : sort;
  
+             if (results.length > 0)
+             {
                  // 既に距離0が追加されている場合は、それ以外の結果だけをソート
                  if (selfAdded && results.length > 1)
```

```diff
                  {
                      sort!((a, b) => a.dist == b.dist ? a.id < b.id : a.dist < b.dist)(results);
+                 }
+             }
+         }
+         catch (Exception e)
+         {
+             // 検索処理中の例外をキャッチして安全に処理
+             writeln("エラー: BK-Tree検索中に例外が発生しました: ", e.msg);
+             // 空の結果を返す
+             results = [];
          }
  
```

---

3. 最後に、BK-Treeとそれ以外のインデックスでファイルを分ける対策を実装します：

---

```diff
  struct IndexCache
  {
-     string path; // キャッシュファイルの絶対パス
+     string path; // 基本キャッシュファイルの絶対パス
+     string bkTreePath; // BK-Tree専用キャッシュファイルの絶対パス
      SysTime lastCsvModTime; // 最後に確認したCSVのタイムスタンプ
      bool needsUpdate; // キャッシュ更新が必要かどうかのフラグ
```

```diff
      {
          path = cachePath;
+         bkTreePath = cachePath ~ ".bktree";
          needsUpdate = false;
          lastCsvModTime = SysTime.min; // 初期値は最小時刻
```

```diff
          return cacheModTime > csvModTime;
      }
+ 
+     // BK-Treeキャッシュファイルが有効かを検証
+     bool isBKTreeValid(string csvPath)
+     {
+         if (!exists(bkTreePath))
+             return false;
+             
+         // CSVファイルの現在の更新時刻を取得
+         auto csvModTime = timeLastModified(csvPath);
+ 
+         // BK-Treeキャッシュファイルの更新時刻
+         auto cacheModTime = timeLastModified(bkTreePath);
+ 
+         return cacheModTime > csvModTime;
+     }
  
      // キャッシュの更新が必要かどうかを返す
```

---

```diff
          ref BKTree bkTree)
      {
-         if (!exists(path))
-             return false;
-         auto file = File(path, "rb");
-         scope (exit)
-             file.close();
-         ubyte[4] mag;
-         file.rawRead(mag[]);
-         
-         // BK-Treeを含むLTC3形式のみ対応
-         if (mag != cast(ubyte[4]) "LTC3")
-             return false;
- 
-         // 基本部分の読み込み（他のインデックス）
-         uint preCnt;
-         readValue!uint(file, preCnt);
-         prefix = new RedBlackTree!string;
-         foreach (i; 0 .. preCnt)
+         bool basicIndexLoaded = false;
+         bool bkTreeLoaded = false;
+         
+         // 基本インデックスの読み込み
+         try {
+             basicIndexLoaded = loadFull(prefix, suffix, gram, lenIdx);
+             if (basicIndexLoaded) {
+                 writeln("基本インデックスキャッシュを読み込みました");
+             }
+         } catch (Exception e) {
+             writeln("警告: 基本インデックスキャッシュの読み込みに失敗しました: ", e.msg);
+         }
+         
+         // BK-Treeの読み込み
+         try {
+             bkTreeLoaded = loadBKTree(bkTree);
+             if (bkTreeLoaded) {
+                 writeln("BK-Tree専用キャッシュを読み込みました");
+             }
+         } catch (Exception e) {
+             writeln("警告: BK-Tree専用キャッシュの読み込みに失敗しました: ", e.msg);
+             // BK-Tree読み込み失敗時は新規作成
+             bkTree = new BKTree(&damerauDistanceLimited, 3);
+         }
+         
+         // 少なくとも基本インデックスが読み込めれば成功とみなす
+         return basicIndexLoaded;
+     }
+ 
+     // BK-Tree専用の保存関数
+     void saveBKTree(BKTree bkTree)
      {
-             ushort l;
-             readValue!ushort(file, l);
-             char[] buf;
-             buf.length = l;
-             file.rawRead(cast(ubyte[]) buf);
-             prefix.insert(cast(string) buf.idup);
-         }
- 
-         uint sufCnt;
-         readValue!uint(file, sufCnt);
-         suffix = new RedBlackTree!string;
-         foreach (i; 0 .. sufCnt)
+         if (shouldUpdate())
+         {
+             try {
+                 writeln("BK-Tree専用キャッシュファイルに保存中...");
+                 
+                 auto file = File(bkTreePath, "wb");
+                 scope (exit)
+                     file.close();
+                 
+                 file.rawWrite(cast(ubyte[]) "BKTR"); // BK-Tree専用マジック
+                 
+                 // BK-Treeの保存
+                 auto nodes = bkTree.serializeForCache();
+                 writeValue!uint(file, cast(uint) nodes.length);
+                 
+                 foreach (node; nodes)
                  {
-             ushort l;
-             readValue!ushort(file, l);
-             char[] buf;
-             buf.length = l;
-             file.rawRead(cast(ubyte[]) buf);
-             suffix.insert(cast(string) buf.idup);
-         }
- 
-         uint gramCnt;
-         readValue!uint(file, gramCnt);
-         gram.clear();
-         foreach (i; 0 .. gramCnt)
+                     // ノードの単語を保存
+                     ushort wordLen = cast(ushort) node.word.length;
+                     writeValue!ushort(file, wordLen);
+                     file.rawWrite(cast(const(ubyte[])) node.word.representation);
+                     
+                     // ノードのIDを保存
+                     writeValue!size_t(file, node.id);
+                     
+                     // このノードの子ノード情報を保存（距離→インデックス）
+                     writeValue!uint(file, cast(uint) node.links.length);
+                     foreach (dist, childIdx; node.links)
                      {
-             ushort l;
-             readValue!ushort(file, l);
-             char[] buf;
-             buf.length = l;
-             file.rawRead(cast(ubyte[]) buf);
-             string g = cast(string) buf.idup;
-             uint idN;
-             readValue!uint(file, idN);
-             GramIndexType set;
-             set.initialize(idN + 1);
-             foreach (j; 0 .. idN)
-             {
-                 uint id;
-                 readValue!uint(file, id);
-                 set.add(id);
+                         writeValue!size_t(file, dist);
+                         writeValue!uint(file, cast(uint) childIdx);
+                     }
+                 }
+                 
+                 writeln("BK-Tree専用キャッシュ保存完了（ノード数: ", nodes.length, "）");
+                 resetUpdateFlag();
+             } 
+             catch (Exception e) {
+                 writeln("エラー: BK-Tree専用キャッシュ保存中に例外が発生: ", e.msg);
              }
-             gram[g] = set;
-         }
- 
-         uint lenCnt;
-         readValue!uint(file, lenCnt);
-         lenIdx.clear();
-         foreach (i; 0 .. lenCnt)
-         {
-             ushort ln;
-             readValue!ushort(file, ln);
-             uint idN;
-             readValue!uint(file, idN);
-             if (ln !in lenIdx)
-                 lenIdx[ln] = null;
-             foreach (j; 0 .. idN)
-             {
-                 uint id;
-                 readValue!uint(file, id);
-                 lenIdx[ln][id] = true;
-             }
-         }
- 
-         // BK-Treeの読み込み
+         }
+     }
+     
+     // BK-Tree専用のロード関数
+     bool loadBKTree(ref BKTree bkTree)
+     {
+         if (!exists(bkTreePath))
+             return false;
+             
+         auto file = File(bkTreePath, "rb");
+         scope (exit)
+             file.close();
+         
+         ubyte[4] mag;
+         file.rawRead(mag[]);
+         
+         // BK-Tree専用マジックをチェック
+         if (mag != cast(ubyte[4]) "BKTR")
+             return false;
+             
+         try {
              uint nodeCnt;
              readValue!uint(file, nodeCnt);
              
              if (nodeCnt > 0)
              {
-             writeln("キャッシュからBK-Treeを読み込んでいます（ノード数: ", nodeCnt, "）...");
-             
-             try {
-                 // シリアライズされたノード情報を読み込む
-                 BKTree.SerializedNode[] nodes;
-                 nodes.length = nodeCnt;
+                 writeln("BK-Tree専用キャッシュから読み込んでいます（ノード数: ", nodeCnt, "）...");
                  
                  // メモリオーバーフローを防ぐための安全チェック
```

```diff
                      return false;
                  }
+                 
+                 // シリアライズされたノード情報を読み込む
+                 BKTree.SerializedNode[] nodes;
+                 nodes.length = nodeCnt;
                  
                  foreach (i; 0 .. nodeCnt)
```

```diff
                  bkTree = new BKTree(&damerauDistanceLimited, 3);
                  bkTree.deserializeFromCache(nodes);
-                 writeln("BK-Tree読み込み完了");
+                 writeln("BK-Tree専用キャッシュから読み込み完了");
                  return true;
+             }
          } catch (Exception e) {
-                 writeln("BK-Tree読み込み中にエラーが発生しました: ", e.msg);
+             writeln("BK-Tree専用キャッシュ読み込み中にエラーが発生しました: ", e.msg);
              return false;
-             }
          }
          
          return false;
      }
+ 
+     void saveComplete(
+         RedBlackTree!string prefix,
+         RedBlackTree!string suffix,
+         GramIndexType[string] gram,
+         bool[size_t][size_t] lenIdx,
+         BKTree bkTree)
+     {
+         // 基本インデックスキャッシュを保存
+         try {
+             writeln("基本インデックスをキャッシュに保存します...");
+             saveFull(prefix, suffix, gram, lenIdx);
+             writeln("基本インデックスキャッシュの保存に成功しました。");
+         } catch (Exception e) {
+             writeln("警告: 基本インデックスキャッシュの保存に失敗しました: ", e.msg);
+         }
+         
+         // BK-Tree専用キャッシュを保存
+         try {
+             saveBKTree(bkTree);
+         } catch (Exception e) {
+             writeln("警告: BK-Tree専用キャッシュの保存に失敗しました: ", e.msg);
+         }
+     }
+ 
+     bool loadComplete(out RedBlackTree!string prefix,
+         out RedBlackTree!string suffix,
+         ref GramIndexType[string] gram,
+         ref bool[size_t][size_t] lenIdx,
+         ref BKTree bkTree)
+     {
+         bool basicIndexLoaded = false;
+         bool bkTreeLoaded = false;
+         
+         // 基本インデックスの読み込み
+         try {
+             basicIndexLoaded = loadFull(prefix, suffix, gram, lenIdx);
+             if (basicIndexLoaded) {
+                 writeln("基本インデックスキャッシュを読み込みました");
+             }
+         } catch (Exception e) {
+             writeln("警告: 基本インデックスキャッシュの読み込みに失敗しました: ", e.msg);
+         }
+         
+         // BK-Treeの読み込み
+         try {
+             bkTreeLoaded = loadBKTree(bkTree);
+             if (bkTreeLoaded) {
+                 writeln("BK-Tree専用キャッシュを読み込みました");
+             }
+         } catch (Exception e) {
+             writeln("警告: BK-Tree専用キャッシュの読み込みに失敗しました: ", e.msg);
+             // BK-Tree読み込み失敗時は新規作成
+             bkTree = new BKTree(&damerauDistanceLimited, 3);
+         }
+         
+         // 少なくとも基本インデックスが読み込めれば成功とみなす
+         return basicIndexLoaded;
+     }
  }
  
```

---



---



---

```bash
cd /home/diverge/D/Search_PoC_D && dmd -run source/language_table.d
```

---

_**User**_



---

_**Assistant**_



---

